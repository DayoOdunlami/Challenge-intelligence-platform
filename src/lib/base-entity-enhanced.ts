/**
 * Enhanced BaseEntity with Provenance & Trust Layer
 * 
 * This extends the base schema to include P0 trust features:
 * - Data provenance (source, ingestion method, dates)
 * - Confidence scores (data quality, verification status)
 * - Audit trail (who/what/when changed)
 * - Filtering support (by confidence, verification, freshness)
 * 
 * These fields are natural parts of the dataset, enabling elegant
 * filtering, auditing, and quality tracking as data grows.
 */

import type { BaseEntity as BaseEntityCore, EntityType, Domain, TRLValue, UniversalRelationship as UniversalRelationshipCore } from './base-entity';

/**
 * Data Source - Where did this entity come from?
 */
export type DataSourceType = 
  | 'manual_entry'        // User manually entered
  | 'scraped'             // Automated web scraping
  | 'api_import'          // From external API
  | 'excel_import'        // Imported from Excel
  | 'csv_import'          // Imported from CSV
  | 'expert_curated'      // Domain expert verified
  | 'computed'            // Generated by algorithm
  | 'merged'              // Merged from multiple sources
  | 'unknown';            // Source unknown (legacy data)

/**
 * Verification Status - How trusted is this data?
 */
export type VerificationStatus = 
  | 'verified'            // Expert/automated verification passed
  | 'pending_verification' // Awaiting verification
  | 'unverified'          // Not yet verified
  | 'flagged'             // Verification failed or concerns raised
  | 'disputed'            // Multiple sources conflict
  | 'auto_verified'       // Automated check passed (lower confidence than verified)
  | 'legacy';             // Old data, verification not attempted

/**
 * Confidence Score - Data quality assessment (0-1)
 * 
 * 0.9-1.0: Excellent - Multiple verified sources, recent
 * 0.7-0.9: Good - Single verified source, recent
 * 0.5-0.7: Fair - Unverified but plausible, or older data
 * 0.3-0.5: Poor - Unverified, single source, or very old
 * 0.0-0.3: Very Poor - Uncertain, disputed, or placeholder data
 */
export type ConfidenceScore = number; // 0-1

/**
 * Provenance - Complete data lineage and trust information
 */
export interface Provenance {
  /** Where did this data come from? */
  source: {
    type: DataSourceType;
    /** Human-readable source name/URL */
    name: string;
    /** Source URL, file path, or reference */
    reference?: string;
    /** Which ingestion pipeline/system created this */
    ingestedBy?: string;
    /** Date when data was first ingested */
    ingestedAt: string; // ISO 8601
    /** External ID from source system (if applicable) */
    externalId?: string;
  };

  /** How fresh is this data? */
  freshness: {
    /** When was this data last updated from source? */
    lastUpdatedAt: string; // ISO 8601
    /** When was this data last verified/refreshed? */
    lastVerifiedAt?: string; // ISO 8601
    /** How old is this data? (in days, computed) */
    ageInDays?: number; // Computed field
    /** Is this data stale? (>90 days = stale) */
    isStale?: boolean; // Computed field
  };

  /** Data quality and verification */
  quality: {
    /** Overall confidence score (0-1) */
    confidence: ConfidenceScore;
    /** Verification status */
    verificationStatus: VerificationStatus;
    /** Who verified this? (user ID, system name, or 'automated') */
    verifiedBy?: string;
    /** When was it verified? */
    verifiedAt?: string; // ISO 8601
    /** Quality score breakdown (optional, for transparency) */
    qualityBreakdown?: {
      completeness: number; // 0-1: How complete is the data?
      accuracy: number;     // 0-1: How accurate (based on verification)?
      timeliness: number;   // 0-1: How fresh is the data?
      sourceReliability: number; // 0-1: How reliable is the source?
    };
  };

  /** Audit trail - who changed what and when */
  audit: {
    /** Who created this entity? */
    createdBy?: string; // User ID or system name
    /** When was it created? */
    createdAt: string; // ISO 8601
    /** Last modification history (last 10 changes) */
    changeHistory?: Array<{
      timestamp: string; // ISO 8601
      changedBy: string; // User ID or system name
      changeType: 'create' | 'update' | 'delete' | 'verify' | 'flag';
      field?: string; // Which field changed (optional)
      oldValue?: unknown; // Previous value (optional)
      newValue?: unknown; // New value (optional)
      reason?: string; // Why was this change made?
    }>;
  };

  /** Data quality flags - issues or concerns */
  flags?: Array<{
    type: 'missing_field' | 'outdated' | 'conflicting_source' | 'unverified' | 'low_confidence' | 'duplicate' | 'custom';
    severity: 'info' | 'warning' | 'error';
    message: string;
    field?: string; // Which field has the issue
    flaggedAt: string; // ISO 8601
    flaggedBy?: string; // User ID or system
    resolvedAt?: string; // ISO 8601
    resolvedBy?: string; // User ID
  }>;
}

/**
 * Enhanced BaseEntity with Provenance
 */
export interface BaseEntity extends BaseEntityCore {
  /** P0: Provenance and trust information - REQUIRED for all entities */
  provenance: Provenance;
  
  /** Computed convenience fields for filtering (derived from provenance) */
  _computed?: {
    /** Is this entity trustworthy? (confidence > 0.7 && verified) */
    isTrustworthy?: boolean;
    /** Should this be shown by default? (filters out low-quality data) */
    showByDefault?: boolean;
    /** Data quality tier */
    qualityTier?: 'high' | 'medium' | 'low' | 'very_low';
  };
}

/**
 * Enhanced UniversalRelationship with Provenance
 */
export interface UniversalRelationship extends UniversalRelationshipCore {
  /** P0: Provenance for relationships - especially important for computed relationships */
  provenance: {
    /** How was this relationship derived? */
    derivation: 'explicit' | 'computed' | 'inferred' | 'manual';
    
    /** Source of relationship */
    source?: {
      type: DataSourceType;
      name: string;
      reference?: string;
      ingestedAt: string;
    };
    
    /** Relationship confidence (0-1) */
    confidence: ConfidenceScore;
    
    /** Verification status */
    verificationStatus?: VerificationStatus;
    verifiedBy?: string;
    verifiedAt?: string;
    
    /** When was this relationship created/last updated? */
    createdAt: string;
    updatedAt?: string;
    
    /** For computed relationships: algorithm details */
    computation?: {
      algorithm: string; // e.g., 'keyword_similarity', 'semantic_embedding', 'ml_model_v1'
      parameters?: Record<string, unknown>; // Algorithm parameters
      explanation?: string; // Human-readable explanation
    };
    
    /** Audit trail */
    audit?: {
      createdBy?: string;
      changeHistory?: Array<{
        timestamp: string;
        changedBy: string;
        changeType: 'create' | 'update' | 'delete' | 'verify';
        reason?: string;
      }>;
    };
    
    /** Quality flags */
    flags?: Array<{
      type: 'low_confidence' | 'unverified' | 'conflicting' | 'custom';
      severity: 'info' | 'warning' | 'error';
      message: string;
      flaggedAt: string;
    }>;
  };
}

/**
 * Filters for entities based on provenance/trust
 */
export interface ProvenanceFilter {
  /** Filter by confidence score */
  minConfidence?: ConfidenceScore;
  maxConfidence?: ConfidenceScore;
  
  /** Filter by verification status */
  verificationStatus?: VerificationStatus[];
  /** Only show verified entities */
  verifiedOnly?: boolean;
  
  /** Filter by data freshness */
  maxAgeInDays?: number; // Exclude data older than X days
  /** Only show fresh data (<90 days) */
  freshOnly?: boolean;
  
  /** Filter by source type */
  sourceTypes?: DataSourceType[];
  /** Exclude certain source types */
  excludeSourceTypes?: DataSourceType[];
  
  /** Filter by quality tier */
  qualityTiers?: Array<'high' | 'medium' | 'low' | 'very_low'>;
  
  /** Filter by data quality flags */
  excludeFlagged?: boolean; // Exclude entities with any flags
  excludeSeverity?: Array<'info' | 'warning' | 'error'>; // Exclude entities with these flag severities
}

/**
 * Enhanced EntityFilter with provenance support
 */
export interface EnhancedEntityFilter {
  // Original filters
  entityTypes?: EntityType[];
  sectors?: string[];
  tags?: string[];
  trlRange?: { min: number; max: number };
  status?: string[];
  searchQuery?: string;
  
  // Provenance filters
  provenance?: ProvenanceFilter;
}

/**
 * Helper: Compute age and staleness from provenance
 */
export function computeProvenanceMetrics(provenance: Provenance): {
  ageInDays: number;
  isStale: boolean;
  qualityTier: 'high' | 'medium' | 'low' | 'very_low';
  isTrustworthy: boolean;
} {
  const lastUpdated = new Date(provenance.freshness.lastUpdatedAt);
  const now = new Date();
  const ageInDays = Math.floor((now.getTime() - lastUpdated.getTime()) / (1000 * 60 * 60 * 24));
  const isStale = ageInDays > 90;
  
  // Compute quality tier from confidence
  const confidence = provenance.quality.confidence;
  let qualityTier: 'high' | 'medium' | 'low' | 'very_low';
  if (confidence >= 0.8) qualityTier = 'high';
  else if (confidence >= 0.6) qualityTier = 'medium';
  else if (confidence >= 0.4) qualityTier = 'low';
  else qualityTier = 'very_low';
  
  // Trustworthy = high confidence + verified + fresh
  const isTrustworthy = 
    confidence >= 0.7 && 
    provenance.quality.verificationStatus === 'verified' && 
    !isStale;
  
  return {
    ageInDays,
    isStale,
    qualityTier,
    isTrustworthy,
  };
}

/**
 * Helper: Filter entities by provenance
 */
export function filterByProvenance<T extends BaseEntity>(
  entities: T[],
  filter: ProvenanceFilter
): T[] {
  return entities.filter(entity => {
    const { provenance } = entity;
    const metrics = computeProvenanceMetrics(provenance);
    
    // Confidence filter
    if (filter.minConfidence !== undefined && provenance.quality.confidence < filter.minConfidence) {
      return false;
    }
    if (filter.maxConfidence !== undefined && provenance.quality.confidence > filter.maxConfidence) {
      return false;
    }
    
    // Verification filter
    if (filter.verifiedOnly && provenance.quality.verificationStatus !== 'verified') {
      return false;
    }
    if (filter.verificationStatus && !filter.verificationStatus.includes(provenance.quality.verificationStatus)) {
      return false;
    }
    
    // Freshness filter
    if (filter.maxAgeInDays !== undefined && metrics.ageInDays > filter.maxAgeInDays) {
      return false;
    }
    if (filter.freshOnly && metrics.isStale) {
      return false;
    }
    
    // Source type filter
    if (filter.sourceTypes && !filter.sourceTypes.includes(provenance.source.type)) {
      return false;
    }
    if (filter.excludeSourceTypes && filter.excludeSourceTypes.includes(provenance.source.type)) {
      return false;
    }
    
    // Quality tier filter
    if (filter.qualityTiers && !filter.qualityTiers.includes(metrics.qualityTier)) {
      return false;
    }
    
    // Flags filter
    if (filter.excludeFlagged && provenance.flags && provenance.flags.length > 0) {
      return false;
    }
    if (filter.excludeSeverity && provenance.flags) {
      const hasExcludedSeverity = provenance.flags.some(flag => 
        filter.excludeSeverity!.includes(flag.severity)
      );
      if (hasExcludedSeverity) return false;
    }
    
    return true;
  });
}

/**
 * Helper: Create default provenance for new entities
 */
export function createDefaultProvenance(source: {
  type: DataSourceType;
  name: string;
  reference?: string;
  ingestedBy?: string;
}): Provenance {
  const now = new Date().toISOString();
  
  return {
    source: {
      type: source.type,
      name: source.name,
      reference: source.reference,
      ingestedBy: source.ingestedBy || 'system',
      ingestedAt: now,
    },
    freshness: {
      lastUpdatedAt: now,
      lastVerifiedAt: undefined,
      ageInDays: 0,
      isStale: false,
    },
    quality: {
      confidence: getDefaultConfidenceForSource(source.type),
      verificationStatus: 'unverified',
      verifiedBy: undefined,
      verifiedAt: undefined,
    },
    audit: {
      createdAt: now,
      changeHistory: [{
        timestamp: now,
        changedBy: source.ingestedBy || 'system',
        changeType: 'create',
        reason: `Imported from ${source.name}`,
      }],
    },
    flags: [],
  };
}

/**
 * Helper: Get default confidence based on source type
 */
function getDefaultConfidenceForSource(sourceType: DataSourceType): ConfidenceScore {
  switch (sourceType) {
    case 'expert_curated':
      return 0.95;
    case 'verified':
      return 0.90;
    case 'api_import':
      return 0.75;
    case 'excel_import':
    case 'csv_import':
      return 0.70;
    case 'scraped':
      return 0.60;
    case 'computed':
      return 0.50;
    case 'manual_entry':
      return 0.65;
    case 'merged':
      return 0.80;
    case 'unknown':
      return 0.30;
    default:
      return 0.50;
  }
}

/**
 * Helper: Add audit entry to provenance
 */
export function addAuditEntry(
  provenance: Provenance,
  entry: {
    changedBy: string;
    changeType: 'create' | 'update' | 'delete' | 'verify' | 'flag';
    field?: string;
    oldValue?: unknown;
    newValue?: unknown;
    reason?: string;
  }
): Provenance {
  const now = new Date().toISOString();
  const changeHistory = provenance.audit.changeHistory || [];
  
  return {
    ...provenance,
    audit: {
      ...provenance.audit,
      changeHistory: [
        {
          timestamp: now,
          ...entry,
        },
        ...changeHistory.slice(0, 9), // Keep last 10 entries
      ],
    },
    freshness: {
      ...provenance.freshness,
      lastUpdatedAt: now,
    },
  };
}

/**
 * Helper: Mark entity as verified
 */
export function markAsVerified(
  provenance: Provenance,
  verifiedBy: string,
  confidence?: ConfidenceScore
): Provenance {
  const now = new Date().toISOString();
  
  return {
    ...provenance,
    quality: {
      ...provenance.quality,
      confidence: confidence ?? Math.min(0.95, provenance.quality.confidence + 0.2),
      verificationStatus: 'verified',
      verifiedBy,
      verifiedAt: now,
    },
    freshness: {
      ...provenance.freshness,
      lastVerifiedAt: now,
    },
  };
}

/**
 * Helper: Add quality flag to entity
 */
export function addQualityFlag(
  provenance: Provenance,
  flag: {
    type: Provenance['flags'][number]['type'];
    severity: 'info' | 'warning' | 'error';
    message: string;
    field?: string;
    flaggedBy?: string;
  }
): Provenance {
  const now = new Date().toISOString();
  const flags = provenance.flags || [];
  
  return {
    ...provenance,
    flags: [
      ...flags,
      {
        ...flag,
        flaggedAt: now,
        flaggedBy: flag.flaggedBy || 'system',
      },
    ],
    quality: {
      ...provenance.quality,
      // Reduce confidence slightly when flagged
      confidence: Math.max(0.1, provenance.quality.confidence - 0.1),
      verificationStatus: 'flagged',
    },
  };
}

